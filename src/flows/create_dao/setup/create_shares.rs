use crate::{
    capi_deps::CapiAssetDaoDeps,
    flows::create_dao::{
        model::{CreateAssetsToSign, CreateImageNftToSign, CreateSharesSpecs},
        setup_dao_specs::SetupDaoSpecs,
    },
    network_util::wait_for_pending_transaction,
};
use algonaut::{
    algod::v2::Algod,
    core::{to_app_address, Address, SuggestedTransactionParams},
    model::algod::v2::PendingTransaction,
    transaction::{CreateAsset, SignedTransaction, Transaction, TxnBuilder},
};
use anyhow::{anyhow, Result};
use futures::{join, FutureExt};
use mbase::{
    api::version::VersionedTealSourceTemplate,
    models::{
        dao_app_id::DaoAppId,
        nft::{Cid, Nft},
    },
};

use super::create_app::create_app_tx;

pub async fn create_assets(
    algod: &Algod,
    creator: &Address,
    specs: &SetupDaoSpecs,
    app_approval: &VersionedTealSourceTemplate,
    app_clear: &VersionedTealSourceTemplate,
    precision: u64,
    capi_deps: &CapiAssetDaoDeps,
) -> Result<CreateAssetsToSign> {
    let params = algod.suggested_transaction_params().await?;
    let create_shares_tx = &mut create_shares_tx(&params, &specs.shares, *creator).await?;

    let create_app_tx = &mut create_app_tx(
        algod,
        app_approval,
        app_clear,
        creator,
        specs.shares.supply,
        precision,
        specs.investors_share,
        &params,
        capi_deps,
        specs.share_price,
    )
    .await?;

    // tx to create image nft if there's an image (cid, generated by the frontend)
    let create_image_nft = if let Some(cid) = specs.image_cid.clone() {
        Some(CreateImageNftToSign {
            tx: create_nft_tx(algod, cid.clone(), &creator).await?,
            cid,
        })
    } else {
        None
    };

    Ok(CreateAssetsToSign {
        create_shares_tx: create_shares_tx.clone(),
        create_app_tx: create_app_tx.clone(),
        create_image_nft,
    })
}

pub async fn submit_create_assets(
    algod: &Algod,
    signed: &CreateDaoAssetsSigned,
) -> Result<CreateAssetsResult> {
    log::debug!("Submitting create assets..");

    // let txs = vec![signed.create_app.clone()];
    // mbase::teal::debug_teal_rendered(&vec![signed.create_app.clone()], "dao_app_approval")
    //     .unwrap();

    // Note that we don't use a tx group here but send the transactions separately,
    // When in a group, the resulting pending transaction contains an id (app id / asset id) only for the first tx in the group.
    // TODO confirm that it's not possible to bundle these 3 in a group. or maybe inner txs somehow?

    // see testing::algorand_checks::cannot_create_asset_and_app_in_same_group
    let shares_asset_id_fut = send_and_retrieve_asset_id(algod, &signed.create_shares);
    let app_id_fut = send_and_retrieve_app_id(algod, &signed.create_app);
    let image_nft_asset_id_fut = match &signed.create_image_nft {
        Some(signed) => {
            let cid = signed.cid.clone();
            Some(send_and_retrieve_asset_id(algod, &signed.tx).map(|res| (res, cid)))
        }
        None => None,
    };

    let (shares_asset_id_res, app_id_res, image_nft_res) = match image_nft_asset_id_fut {
        Some(tx_fut) => {
            let tuple = join!(shares_asset_id_fut, app_id_fut, tx_fut);
            (tuple.0, tuple.1, Some(tuple.2))
        }
        None => {
            let tuple = join!(shares_asset_id_fut, app_id_fut);
            (tuple.0, tuple.1, None)
        }
    };

    let shares_asset_id = shares_asset_id_res?;
    let app_id = app_id_res?;
    let image_nft = match image_nft_res {
        Some((asset_id_res, cid)) => Some(Nft {
            asset_id: asset_id_res?,
            cid,
        }),
        None => None,
    };

    let app_address = to_app_address(app_id.0);

    log::debug!("Dao assets created. Shares id: {shares_asset_id}, app id: {app_id:?}, app address: {app_address:?}");

    Ok(CreateAssetsResult {
        shares_asset_id,
        app_id,
        image_nft,
    })
}

async fn send_and_retrieve_asset_id(algod: &Algod, tx: &SignedTransaction) -> Result<u64> {
    let p_tx = send_and_wait_for_pending_tx(algod, tx).await?;
    p_tx.asset_index
        .ok_or_else(|| anyhow!("Shares asset id in pending tx not set"))
}

async fn send_and_retrieve_app_id(algod: &Algod, tx: &SignedTransaction) -> Result<DaoAppId> {
    let p_tx = send_and_wait_for_pending_tx(algod, tx).await?;
    Ok(DaoAppId(
        p_tx.application_index
            .ok_or_else(|| anyhow!("App id in pending tx not set"))?,
    ))
}

async fn send_and_wait_for_pending_tx(
    algod: &Algod,
    tx: &SignedTransaction,
) -> Result<PendingTransaction> {
    let res = algod.broadcast_signed_transaction(tx).await?;
    wait_for_pending_transaction(algod, &res.tx_id.parse()?)
        .await?
        .ok_or_else(|| anyhow!("No pending tx to retrieve asset_od"))
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateDaoAssetsSigned {
    pub create_shares: SignedTransaction,
    pub create_app: SignedTransaction,
    pub create_image_nft: Option<CreateImageNftSigned>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CreateImageNftSigned {
    pub tx: SignedTransaction,
    pub cid: Cid,
}

#[derive(Debug)]
pub struct CreateAssetsResult {
    pub shares_asset_id: u64,
    pub app_id: DaoAppId,
    pub image_nft: Option<Nft>,
}

async fn create_shares_tx(
    params: &SuggestedTransactionParams,
    shares_specs: &CreateSharesSpecs,
    creator: Address,
) -> Result<Transaction> {
    let unit_and_asset_name = shares_specs.token_name.to_owned();
    Ok(TxnBuilder::with(
        params,
        CreateAsset::new(creator, shares_specs.supply.val(), 0, false)
            .unit_name(unit_and_asset_name.clone())
            .asset_name(unit_and_asset_name)
            .build(),
    )
    .build()?)
}

async fn create_nft_tx(algod: &Algod, cid: Cid, owner: &Address) -> Result<Transaction> {
    let params = algod.suggested_transaction_params().await?;
    Ok(TxnBuilder::with(
        &params,
        CreateAsset::new(*owner, 1, 0, false)
            .unit_name("IMG".to_owned())
            .asset_name("IMG".to_owned())
            .manager(*owner) // allows to set properties, like high res image with arc69
            .url(format!("ipfs://{}", cid.0))
            .build(),
    )
    .build()?)
}
