#pragma version 4

gtxn 0 NumAppArgs
int 2
==
bz after_args_access
gtxn 0 ApplicationArgs 0 // action
byte b64 YnJhbmNoX2luaXRfcmVxdWVzdA== // branch_init_request
==
&&
bnz branch_init_request

gtxn 0 NumAppArgs
int 2
==
bz after_args_access
gtxn 0 ApplicationArgs 0 // action
byte b64 YnJhbmNoX3dpdGhkcmF3 // branch_withdraw
==
&&
bnz branch_withdraw

after_args_access:

global GroupSize
int 1
==
bnz branch_opt_in

branch_init_request:

// there's no active request (amount is 0)
byte "Amount"
app_global_get
int 0
==

gtxn 0 TypeEnum // app call
int appl
==

// amount >= 0 (setting 0 amount means clearing the request)
gtxn 0 ApplicationArgs 1 // withdrawal amount
int 0
>=

// sender is project creator
gtxn 0 Sender
addr {project_creator_address}
==
&&

// save request amount
byte "Amount"
gtxn 0 ApplicationArgs 1 // withdrawal amount
app_global_put

int 1
return

branch_withdraw:

// there's an active request (amount > 0)
byte "Amount"
app_global_get
int 0
>

gtxn 0 TypeEnum // app call
int appl
==
&&

gtxn 1 TypeEnum // payment
int pay
==
&&

// payment amount == requested amount
gtxn 1 Amount
byte "Amount"
app_global_get
==
&&

// payment receiver is project creator
gtxn 1 Receiver
addr {project_creator_address}
==
&&

// enough votes
byte "Votes"
app_global_get
int {vote_threshold}
>=
&&

// reset amount
byte "Amount"
int 0
app_global_put
&&

// reset votes
byte "Votes"
int 0
app_global_put
&&

int 1
return

branch_opt_in:
int 1 // TODO remove
return


// state:
// 1) Amount global state: the amount to be withdrawn
// 2) Votes global state: amount of votes for the current withdrawal request (Amount)
// 3) Voted local state: set when voting, to prevent double voting.

// groups:

// 1) create request: 
// - app call to set amount gs 
// checks:
// current amount gs == 0 (or other default value)
// app call sender if project creator

// 2) withdrawal:
// - pay X algos funds_escrow -> project creator
// - set amount gs to 0 (or other default value)
// - set votes gs to 0
// checks:
// X algos == amount gs
// votes >= threshold

// 3) vote:
// - app call to increment votes gs and set voted count ls
// - app call to central, to validate voted count == owned shares count 
// checks:
// current amount gs > 0 (there's a request)
// already voted ls not set (not voted for this request yet)

// 4) unstake:
// - app opt out call to all slots -> decrements votes gs and clears local state
// - app opt out from central, which validates that ALL slots are being opted out, asset xfer to investor and clears local state too

// later: "valid state" ls to prevent investors from clearing their local state to e.g. double vote (TODO list all possible goals of clearing local state)
// so e.g. with double voting: investor can clear state in a specific slot, removing already voted count and keeping the shares (which are in central)
// so we set "valid state" flag in each slot, and on any critical (stateful?) interaction like voting or unstaking we check that valid state is set on all apps. 
// OR we limit the "valid state" check only to the respective slot (i.e. when voting), so investor can "trick" while keeping their shares, but can never vote again in this slot (which prevents double voting)
// later is better as it reduces tx overhead - we just have to check for valid state in current app when voting 

