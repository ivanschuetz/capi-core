#pragma version 4
// int 1

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Identification
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

gtxn 0 TypeEnum 
int appl
==
gtxn 0 ApplicationID
int 0
==
&&
bnz branch_create

// opt in (only investors opt in)
global GroupSize
int 1
==
bnz branch_opt_in

global GroupSize
int 2 
==
bz not_group_size_2

gtxn 0 NumAppArgs
int 1
==
bz not_harvest
gtxn 0 ApplicationArgs 0
byte b64 aGFydmVzdA==
==
bnz branch_harvest
not_harvest:

gtxn 0 TypeEnum 
int appl
==
gtxn 0 NumAppArgs
int 1
==
&&
bz not_unlock
gtxn 0 ApplicationArgs 0
byte b64 dW5sb2Nr // unlock
==
gtxn 1 TypeEnum // unlock shares
int axfer
==
&&
bnz branch_unlock
not_unlock:

b branch_lock

not_group_size_2:

global GroupSize
int 4
==
bnz branch_drain

b failure

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Handling
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

branch_create:
gtxn 0 ApplicationID
int 0
==
return

branch_opt_in:
gtxn 0 TypeEnum 
int appl
==
int OptIn 
gtxn 0 OnCompletion
==
&&
return

branch_lock:
gtxn 0 TypeEnum // app call
int appl
==
int NoOp 
gtxn 0 OnCompletion
==
&&
gtxn 1 TypeEnum // lock
int axfer
==
&&
// the app caller is locking the shares
gtxn 0 Sender
gtxn 1 Sender
==
&&
// locking capi asset
gtxn 1 XferAsset
int {capi_asset_id}
==
&&
callsub lock_shares
b success

branch_harvest:
gtxn 0 TypeEnum // app call
int appl
==
int NoOp 
gtxn 0 OnCompletion
==
&&
gtxn 1 TypeEnum // harvest
int axfer
==
&&
gtxn 1 XferAsset
int {funds_asset_id}
==
&&
// the app caller is the dividend receiver
gtxn 0 Sender
gtxn 1 AssetReceiver
==
&&

// calculate entitled harvest amount
gtxn 0 Sender
callsub get_locked_shares
callsub entitled_harvest_amount_for_shares
// subtract already harvested amount
gtxn 0 Sender
callsub get_harvested_total
-

// is the xfer less or equal to entitled amount?
gtxn 1 AssetAmount
>=
&&
bz failure

// update harvested amount
gtxn 0 Sender
callsub get_harvested_total
gtxn 1 AssetAmount // harvest tx amount
+
gtxn 0 Sender
callsub set_harvested_total

b success

branch_unlock:
gtxn 0 OnCompletion // app opt out
int CloseOut 
==
gtxn 1 TypeEnum // unlock
int axfer
==
&&
gtxn 1 XferAsset
int {capi_asset_id}
==
&&
// the app caller is the dividend receiver
gtxn 1 AssetReceiver
gtxn 0 Sender
==
&&
// check shares xfer == owned shares count
gtxn 1 AssetAmount
int 0
callsub get_locked_shares
==
&&
return

branch_drain:
gtxn 0 TypeEnum // app call
int appl
==
int NoOp
gtxn 0 OnCompletion
==
&&
gtxn 1 TypeEnum // capi app call
int appl
==
&&
int NoOp
gtxn 1 OnCompletion
==
&&
gtxn 2 TypeEnum // drain
int axfer
==
&&
gtxn 3 TypeEnum // capi share
int axfer
==
&&
// the same user is sending both app calls
gtxn 1 Sender
gtxn 0 Sender
==
&&
// note that we can't check sender/receiver of the drain tx here, as those are DAO specific

// TODO - store capi escrow in global state
// the receiver of the capi share is the capi escrow
// gtxn 3 AssetReceiver
// <get escrow global state>
// ==

// TODO check capi share and drain amount, based on customer escrow's holdings (gtxn 2 sender)

// Increase total received amount
callsub get_received_total
gtxn 3 AssetAmount // capi share tx amount
+
callsub set_received_total

return

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Subroutines
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// expected: [account]
get_received_total:
byte "ReceivedTotal"
app_global_get
retsub

// expected: [value]
set_received_total:
byte "ReceivedTotal"
dig 1
app_global_put
pop
retsub

// expected: [account]
get_harvested_total:
byte "HarvestedTotal"
app_local_get // if local state doesn't exist yet, this puts a 0 on the stack
retsub

// expected: [value, account]
set_harvested_total:
byte "HarvestedTotal"
dig 2
app_local_put
pop
retsub

// expected: [account]
get_locked_shares:
byte "Shares"
app_local_get
retsub

// expected: [value, account]
set_locked_shares:
byte "Shares"
dig 2
app_local_put
pop
retsub

// expects the 2 first txs of invest / lock to be the app call and lock (shares transfer to locking escrow)
// duplicated in: app_central_approval, app_capi_approval
lock_shares:
// sanity: don't allow locking 0 shares 
gtxn 1 AssetAmount
int 0
!=

// initialize / increment shares
gtxn 0 Sender
byte "Shares"
gtxn 0 Sender
byte "Shares"
app_local_get
gtxn 1 AssetAmount // shares bought
+
app_local_put

// initialize already retrieved (ends with app_local_put at the end of /////// block)
gtxn 0 Sender // sender of app call (investor)
byte "HarvestedTotal"
// NOTE that this sets HarvestedTotal to the entitled amount each time that the investor buys/locks shares
// meaning that investors may lose pending dividend by buying or locking new shares (as everything will be practically marked as "already harvested")
// TODO improve? - a non TEAL way could be to just automatically retrieve pending dividend in the same group 
// see more notes in old repo
gtxn 1 AssetAmount // shares bought
callsub entitled_harvest_amount_for_shares
app_local_put

retsub

// What amount (share of total retrieved funds) correspond to investor's share
// Does *not* account for already harvested funds.
// arg: owned shares
entitled_harvest_amount_for_shares:
// entitled % based on owned shares
int {precision}
*
int {asset_supply} 
/

// apply % to central total received
byte "ReceivedTotal"
app_global_get
*
int {precision} // revert mult
/

retsub

success:
int 1
return

failure:
int 0
return
