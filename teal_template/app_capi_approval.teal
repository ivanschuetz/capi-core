#pragma version 4
// int 1

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Identification
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

txn ApplicationID
int 0
==
bnz branch_create

// opt in (only investors opt in)
global GroupSize
int 1
==
bnz branch_opt_in

global GroupSize
int 2 
==
bz not_group_size_2

gtxn 0 NumAppArgs
int 1
==
bz not_harvest
gtxn 0 ApplicationArgs 0
byte b64 aGFydmVzdA==
==
bnz branch_harvest
not_harvest:

gtxn 0 TypeEnum 
int appl
==
gtxn 0 NumAppArgs
int 1
==
&&
bz not_opt_out
gtxn 0 ApplicationArgs 0
byte b64 dW5sb2Nr // unlock
==
int CloseOut 
gtxn 0 OnCompletion // central opt out (TODO app ids?)
==
&&
gtxn 1 TypeEnum // unlock shares
int axfer
==
&&
bnz branch_opt_out
not_opt_out:

b branch_lock

not_group_size_2:

global GroupSize
int 4
==
bnz branch_drain

b failure

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Handling
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

branch_create:
b success

branch_opt_in:
b success

branch_lock:
gtxn 0 TypeEnum // app call
int appl
==
gtxn 1 TypeEnum // lock
int axfer
==
&&
// don't allow locking 0 assets 
// no particular reason, just doesn't make sense
gtxn 1 AssetAmount
int 0
!=
&&
// initialize / increment shares
gtxn 0 Sender
byte "Shares"
gtxn 0 Sender
byte "Shares"
app_local_get
gtxn 1 AssetAmount // shares bought
+
app_local_put

// initialize HarvestedTotal local state to what the shares are entitled to
// see more notes in old repo
gtxn 0 Sender // sender of app call (investor)
byte "HarvestedTotal"
gtxn 1 AssetAmount // locked xfer (this will become "holdings", if the group passes)
callsub entitled_harvest_amount_for_shares
app_local_put

return

branch_harvest:
gtxn 0 TypeEnum // app call
int appl
==
gtxn 1 TypeEnum // harvest
int axfer
==
&&

// calculate entitled harvest amount
gtxn 0 Sender
byte "Shares"
app_local_get
callsub entitled_harvest_amount_for_shares
// subtract already harvested amount
int 0
byte "HarvestedTotal"
app_local_get // if local state doesn't exist yet, this puts a 0 on the stack
-

// is the xfer less or equal to entitled amount?
gtxn 1 AssetAmount
>=
&&
bz failure

// update harvested amount
int 0
byte "HarvestedTotal"
int 0
byte "HarvestedTotal"
app_local_get
gtxn 1 AssetAmount // harvest tx amount
+
app_local_put

b success

branch_opt_out:
// check there's shares xfer
gtxn 1 TypeEnum // unlock
int axfer
==
// check shares xfer goes to the investor (app call tx sender) - review whether this check is really needed
// we can also check e.g. that all the app calls have the same sender
gtxn 1 AssetReceiver
gtxn 0 Sender
==
&&
// check shares xfer == owned shares count
gtxn 1 AssetAmount
int 0
byte "Shares"
app_local_get
==
&&
return

branch_drain:
gtxn 0 TypeEnum // app call
int appl
==
gtxn 1 TypeEnum // capi app call
int appl
==
&&
gtxn 2 TypeEnum // drain
int axfer
==
&&
gtxn 3 TypeEnum // capi share
int axfer
==
&&

// Increase total received amount
byte "ReceivedTotal"
byte "ReceivedTotal"
app_global_get
gtxn 3 AssetAmount // capi share tx amount
+
app_global_put

return

// local state (owned shares) is cleared automatically by CloseOut

// What amount (share of total retrieved funds) correspond to investor's share
// Does *not* account for already harvested funds.
// arg: owned shares
entitled_harvest_amount_for_shares:
int {precision}
*
// the asset's total supply
int {asset_supply} 
// user's holdings % of total received
/
// how much has been transferred (total) to the central
byte "ReceivedTotal"
app_global_get
// percentage user is entitled to from received total
*
int {precision} // revert mult
/

retsub

success:
int 1
return

failure:
int 0
return
